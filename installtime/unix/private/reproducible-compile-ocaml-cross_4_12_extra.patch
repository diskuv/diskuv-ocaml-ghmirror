diff --git a/Makefile b/Makefile
index 41d8e2636..fd42078f3 100644
--- a/Makefile
+++ b/Makefile
@@ -545,7 +545,9 @@ installoptopt:
 	     "$(INSTALL_COMPLIBDIR)"; \
 	fi
 	cd "$(INSTALL_COMPLIBDIR)" && \
-	   $(RANLIB) ocamlcommon.$(A) ocamlbytecomp.$(A) ocamloptcomp.$(A)
+	   $(RANLIB) ocamlcommon.$(A) && \
+	   $(RANLIB) ocamlbytecomp.$(A) && \
+	   $(RANLIB) ocamloptcomp.$(A)
 
 # Installation of the *.ml sources of compiler-libs
 .PHONY: install-compiler-sources
diff --git a/Makefile.config.in b/Makefile.config.in
index 652a1c5ba..59c96d6e5 100644
--- a/Makefile.config.in
+++ b/Makefile.config.in
@@ -229,6 +229,7 @@ WITH_PROFINFO=@profinfo@
 PROFINFO_WIDTH=@profinfo_width@
 WITH_FPIC=@fpic@
 TARGET=@target@
+TARGET_OS=@target_os@
 HOST=@host@
 FLAMBDA=@flambda@
 WITH_FLAMBDA_INVARIANTS=@flambda_invariants@
diff --git a/configure b/configure
index 81a77e3b6..3636e4888 100755
--- a/configure
+++ b/configure
@@ -6558,7 +6558,7 @@ case $with_sysroot in #(
      lt_sysroot=`$CC --print-sysroot 2>/dev/null`
    fi
    ;; #(
- /*)
+ /* | ?:*) # /a/b/c or C:\Windows
    lt_sysroot=`echo "$with_sysroot" | sed -e "$sed_quote_subst"`
    ;; #(
  no|'')
@@ -12751,6 +12751,9 @@ esac
 case $host in #(
   *-*-mingw32|*-pc-windows) :
      ;; #(
+  *-*-linux-android*) :
+    # https://android.googlesource.com/platform/bionic/+/master/docs/32-bit-abi.md
+    ;;
   *) :
     common_cppflags="$common_cppflags -D_FILE_OFFSET_BITS=64" ;;
 esac
@@ -13885,19 +13888,19 @@ else
 fi; system=elf ;; #(
   s390x*-*-linux*) :
     arch=s390x; model=z10; system=elf ;; #(
-  armv6*-*-linux-gnueabihf) :
+  armv6*-*-linux-*eabihf*) :
     arch=arm; model=armv6; system=linux_eabihf ;; #(
-  armv7*-*-linux-gnueabihf) :
+  armv7*-*-linux-*eabihf*) :
     arch=arm; model=armv7; system=linux_eabihf ;; #(
-  armv8*-*-linux-gnueabihf) :
+  armv8*-*-linux-*eabihf*) :
     arch=arm; model=armv8; system=linux_eabihf ;; #(
-  armv8*-*-linux-gnueabi) :
+  armv8*-*-linux-*eabi*) :
     arch=arm; model=armv8; system=linux_eabi ;; #(
-  armv7*-*-linux-gnueabi) :
+  armv7*-*-linux-*eabi*) :
     arch=arm; model=armv7; system=linux_eabi ;; #(
-  armv6t2*-*-linux-gnueabi) :
+  armv6t2*-*-linux-*eabi*) :
     arch=arm; model=armv6t2; system=linux_eabi ;; #(
-  armv6*-*-linux-gnueabi) :
+  armv6*-*-linux-*eabi*) :
     arch=arm; model=armv6; system=linux_eabi ;; #(
   armv6*-*-freebsd*) :
     arch=arm; model=armv6; system=freebsd ;; #(
@@ -13905,13 +13908,13 @@ fi; system=elf ;; #(
     arch=arm; model=armv6; system=netbsd ;; #(
   earmv7*-*-netbsd*) :
     arch=arm; model=armv7; system=netbsd ;; #(
-  armv5te*-*-linux-gnueabi) :
+  armv5te*-*-linux-*eabi*) :
     arch=arm; model=armv5te; system=linux_eabi ;; #(
-  armv5*-*-linux-gnueabi) :
+  armv5*-*-linux-*eabi*) :
     arch=arm; model=armv5; system=linux_eabi ;; #(
-  arm*-*-linux-gnueabihf) :
+  arm*-*-linux-*eabihf*) :
     arch=arm; system=linux_eabihf ;; #(
-  arm*-*-linux-gnueabi) :
+  arm*-*-linux-*eabi*) :
     arch=arm; system=linux_eabi ;; #(
   arm*-*-openbsd*) :
     arch=arm; system=bsd ;; #(
diff --git a/configure.ac b/configure.ac
index 656ffe20c..5f1563c6e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -955,19 +955,19 @@ AS_CASE([$host],
     [arch=power; AS_IF([$arch64],[model=ppc64],[model=ppc]); system=elf],
   [[s390x*-*-linux*]],
     [arch=s390x; model=z10; system=elf],
-  [armv6*-*-linux-gnueabihf],
+  [armv6*-*-linux-*eabihf*],
     [arch=arm; model=armv6; system=linux_eabihf],
-  [armv7*-*-linux-gnueabihf],
+  [armv7*-*-linux-*eabihf*],
     [arch=arm; model=armv7; system=linux_eabihf],
-  [armv8*-*-linux-gnueabihf],
+  [armv8*-*-linux-*eabihf*],
     [arch=arm; model=armv8; system=linux_eabihf],
-  [armv8*-*-linux-gnueabi],
+  [armv8*-*-linux-*eabi*],
     [arch=arm; model=armv8; system=linux_eabi],
-  [armv7*-*-linux-gnueabi],
+  [armv7*-*-linux-*eabi*],
     [arch=arm; model=armv7; system=linux_eabi],
-  [armv6t2*-*-linux-gnueabi],
+  [armv6t2*-*-linux-*eabi*],
     [arch=arm; model=armv6t2; system=linux_eabi],
-  [armv6*-*-linux-gnueabi],
+  [armv6*-*-linux-*eabi*],
     [arch=arm; model=armv6; system=linux_eabi],
   [armv6*-*-freebsd*],
     [arch=arm; model=armv6; system=freebsd],
@@ -975,13 +975,13 @@ AS_CASE([$host],
     [arch=arm; model=armv6; system=netbsd],
   [earmv7*-*-netbsd*],
     [arch=arm; model=armv7; system=netbsd],
-  [armv5te*-*-linux-gnueabi],
+  [armv5te*-*-linux-*eabi*],
     [arch=arm; model=armv5te; system=linux_eabi],
-  [armv5*-*-linux-gnueabi],
+  [armv5*-*-linux-*eabi*],
     [arch=arm; model=armv5; system=linux_eabi],
-  [arm*-*-linux-gnueabihf],
+  [arm*-*-linux-*eabihf*],
     [arch=arm; system=linux_eabihf],
-  [arm*-*-linux-gnueabi],
+  [arm*-*-linux-*eabi*],
     [arch=arm; system=linux_eabi],
   [arm*-*-openbsd*],
     [arch=arm; system=bsd],
diff --git a/runtime/arm.S b/runtime/arm.S
index 612757a10..6d1db9965 100644
--- a/runtime/arm.S
+++ b/runtime/arm.S
@@ -216,10 +216,18 @@ FUNCTION(caml_allocN)
         .size   caml_allocN, .-caml_allocN
 
 /* Call a C function from OCaml */
-/* Function to call is in r7 */
-
-FUNCTION(caml_c_call)
-        CFI_STARTPROC
+/* Function to call is in r7 for non-PIC code, or is a
+   named PLT function for PIC code */
+/* A PLT function address is only available when "cited by a BL-class relocation directive" like `bl func(PLT)`.
+   We can't, for example, do `adr r7, func(PLT)` and then jump to caml_c_call or Ljump_to_caml.
+   So implemented as a macro that inserts the instructions inline and branch jumps (branch_op = bl or blx)
+   to (c_code_addr or caml_code_funcptr). Use blx for r7/r12 register and bl for named PLT functions.
+   Warning: bl does not switch to/from Thumb state since "it is generally pointless trying to construct a PLT entry
+   entirely in 16-bit Thumb instructions". In other words: Do not emit Thumb PLT entries for PIC code!
+   Confer https://github.com/ARM-software/abi-aa/blob/320a56971fdcba282b7001cf4b84abb4fd993131/aaelf32/aaelf32.rst#plt-sequences-and-usage-models .
+*/
+
+        .macro inline_caml_c_call branch_op c_code_addr
     /* Record lowest stack address and return address */
         str     lr, Caml_state(last_return_address)
         str     sp, Caml_state(bottom_of_stack)
@@ -230,25 +238,26 @@ FUNCTION(caml_c_call)
         str     alloc_ptr, Caml_state(young_ptr)
         str     trap_ptr, Caml_state(exception_pointer)
     /* Call the function */
-        blx     r7
+        \branch_op \c_code_addr
     /* Reload alloc ptr */
         ldr     alloc_ptr, Caml_state(young_ptr)
     /* Return */
         bx      r4
+        .endm
+
+FUNCTION(caml_c_call)
+        CFI_STARTPROC
+        inline_caml_c_call blx r7
         CFI_ENDPROC
         .size   caml_c_call, .-caml_c_call
 
 /* Start the OCaml program */
 
-FUNCTION(caml_start_program)
-        CFI_STARTPROC
-        ldr     r12, =caml_program
-
 /* Code shared with caml_callback* */
-/* Address of OCaml code to call is in r12 */
+/* Address of OCaml code to call should either be r12 for non-PIC code, or is a
+   named PLT function for PIC code. Same discussion as inline_caml_c_call */
 /* Arguments to the OCaml code are in r0...r3 */
-
-.Ljump_to_caml:
+        .macro inline_jump_to_caml branch_op caml_code_funcptr
 #if defined(SYS_linux_eabihf) || defined(SYS_netbsd)
     /* Save callee-save floating-point registers */
         vpush   {d8-d15}; CFI_ADJUST(64)
@@ -260,7 +269,14 @@ FUNCTION(caml_start_program)
 #else
         CFI_OFFSET(lr, -4)
 #endif
+#ifdef __PIC__
+    /* get address of 'linked_gsym_Caml_state:' in our .data section */
+        adr     domain_state_ptr, linked_gsym_Caml_state
+    /* read the word at 'linked_gsym_Caml_state:', which is the address of Caml_state itself */
+        ldr     domain_state_ptr, [domain_state_ptr]
+#else
         ldr     domain_state_ptr, =Caml_state
+#endif
         ldr     domain_state_ptr, [domain_state_ptr]
     /* Setup a callback link on the stack */
         sub     sp, sp, 16; CFI_ADJUST(16)              /* 8-byte alignment */
@@ -272,7 +288,7 @@ FUNCTION(caml_start_program)
         str     r6, [sp, 8]
     /* Setup a trap frame to catch exceptions escaping the OCaml code */
         sub     sp, sp, 8; CFI_ADJUST(8)
-        ldr     r5, =.Ltrap_handler
+        adr     r5, .Ltrap_handler
         ldr     r4, Caml_state(exception_pointer)
         str     r4, [sp, 0]
         str     r5, [sp, 4]
@@ -280,7 +296,21 @@ FUNCTION(caml_start_program)
     /* Reload allocation pointer */
         ldr     alloc_ptr, Caml_state(young_ptr)
     /* Call the OCaml code */
-        blx     r12
+        \branch_op \caml_code_funcptr
+        .endm
+
+FUNCTION(caml_start_program)
+        CFI_STARTPROC
+
+#ifdef __PIC__
+        inline_jump_to_caml bl caml_program(PLT)
+#else
+        ldr  r12, =caml_program
+#endif
+
+.Ljump_to_caml:
+    /* Regardless of PIC status, this local label will be used by caml_callback_asm() */
+        inline_jump_to_caml blx r12
 .Lcaml_retaddr:
     /* Pop the trap frame, restoring caml_exception_pointer */
         ldr     r5, [sp, 0]
@@ -397,8 +427,12 @@ FUNCTION(caml_callback2_asm)
         ldr     r0, [r2]          /* r0 = first arg */
         ldr     r1, [r2,4]        /* r1 = second arg */
         mov     r2, r12           /* r2 = closure environment */
-        ldr     r12, =caml_apply2
+#ifdef __PIC__
+        inline_jump_to_caml bl caml_apply2(PLT)
+#else
+        ldr  r12, =caml_apply2
         b       .Ljump_to_caml
+#endif
         CFI_ENDPROC
         .size   caml_callback2_asm, .-caml_callback2_asm
 
@@ -411,17 +445,25 @@ FUNCTION(caml_callback3_asm)
         ldr     r0, [r2]          /* r0 = first arg */
         ldr     r1, [r2,4]        /* r1 = second arg */
         ldr     r2, [r2,8]        /* r2 = third arg */
-        ldr     r12, =caml_apply3
+#ifdef __PIC__
+        inline_jump_to_caml bl caml_apply3(PLT)
+#else
+        ldr  r12, =caml_apply3
         b       .Ljump_to_caml
+#endif
         CFI_ENDPROC
         .size   caml_callback3_asm, .-caml_callback3_asm
 
 FUNCTION(caml_ml_array_bound_error)
         CFI_STARTPROC
+#ifdef __PIC__
+        inline_caml_c_call bl caml_array_bound_error(PLT)
+#else
     /* Load address of [caml_array_bound_error] in r7 */
-        ldr     r7, =caml_array_bound_error
+        ldr  r7, =caml_array_bound_error
     /* Call that function */
         b       caml_c_call
+#endif
         CFI_ENDPROC
         .size   caml_ml_array_bound_error, .-caml_ml_array_bound_error
 
@@ -429,6 +471,14 @@ FUNCTION(caml_ml_array_bound_error)
         .globl  caml_system__code_end
 caml_system__code_end:
 
+#ifdef __PIC__
+/* Constant pool for global offset table entries and other words resolved at link time */
+        .data
+        .align 2
+linked_gsym_Caml_state:
+        .word Caml_state
+#endif
+
 /* GC roots for callback */
 
         .data
diff --git a/runtime/i386.S b/runtime/i386.S
index e1cc5778a..ec27b6102 100644
--- a/runtime/i386.S
+++ b/runtime/i386.S
@@ -78,6 +78,34 @@
 #define CFI_ADJUST(n)
 #endif
 
+/* PIC-friendly macro to get the address of the global variable Caml_state and set it in a register. */
+#ifdef __PIC__
+#define MOV_CAML_STATE_PTR(label, reg) \
+        call    mov_caml_state_##label /* Push IP register */ ; \
+mov_caml_state_##label: \
+        popl    ##reg ; \
+        addl    $_GLOBAL_OFFSET_TABLE_, ##reg ; \
+        movl    Caml_state@GOT(##reg), ##reg
+#else
+#define MOV_CAML_STATE_PTR(label, reg) \
+        movl    G(Caml_state), ##reg
+#endif
+
+/* PIC-friendly macro to call a global function using PLT if PIC */
+        .macro call_global_func name,label
+#ifdef __PIC__
+        pushl   %ebx                           /* Protect ebx */
+        call    call_\label                    /* Push IP register */
+call_\label:
+        popl    %ebx                           /* Pop IP register */
+        addl    $_GLOBAL_OFFSET_TABLE_, %ebx   /* ebx=GOT on PLT entry */
+        call    \name@PLT
+        popl    %ebx
+#else
+        call    G(\name)
+#endif
+        .endm
+
 #if !defined(SYS_mingw) && !defined(SYS_cygwin)
 #define STACK_PROBE_SIZE 16384
 #endif
@@ -116,7 +144,7 @@ FUNCTION(caml_call_gc)
         CFI_STARTPROC
 LBL(caml_call_gc):
     /* Record lowest stack address and return address */
-        movl    G(Caml_state), %ebx
+        MOV_CAML_STATE_PTR(l_caml_call_gc, %ebx)
         movl    (%esp), %eax
         movl    %eax, CAML_STATE(last_return_address, %ebx)
         leal    4(%esp), %eax
@@ -139,7 +167,7 @@ LBL(caml_call_gc):
         movl    %esp, CAML_STATE(gc_regs, %ebx)
         /* MacOSX note: 16-alignment of stack preserved at this point */
     /* Call the garbage collector */
-        call    G(caml_garbage_collection)
+        call_global_func caml_garbage_collection, l_caml_call_gc
     /* Restore all regs used by the code generator */
         popl    %eax; CFI_ADJUST(-4)
         popl    %ebx; CFI_ADJUST(-4)
@@ -156,7 +184,7 @@ LBL(caml_call_gc):
 
 FUNCTION(caml_alloc1)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
+        MOV_CAML_STATE_PTR(l_caml_alloc1, %ebx)
         movl    CAML_STATE(young_ptr, %ebx), %eax
         subl    $8, %eax
         movl    %eax, CAML_STATE(young_ptr, %ebx)
@@ -168,7 +196,7 @@ FUNCTION(caml_alloc1)
 
 FUNCTION(caml_alloc2)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
+        MOV_CAML_STATE_PTR(l_caml_alloc2, %ebx)
         movl    CAML_STATE(young_ptr, %ebx), %eax
         subl    $12, %eax
         movl    %eax, CAML_STATE(young_ptr, %ebx)
@@ -180,7 +208,7 @@ FUNCTION(caml_alloc2)
 
 FUNCTION(caml_alloc3)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
+        MOV_CAML_STATE_PTR(l_caml_alloc3, %ebx)
         movl    CAML_STATE(young_ptr, %ebx), %eax
         subl    $16, %eax
         movl    %eax, CAML_STATE(young_ptr, %ebx)
@@ -192,7 +220,7 @@ FUNCTION(caml_alloc3)
 
 FUNCTION(caml_allocN)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
+        MOV_CAML_STATE_PTR(l_caml_allocN, %ebx)
         /* eax = size - Caml_state->young_ptr */
         subl    CAML_STATE(young_ptr, %ebx), %eax
         negl    %eax              /* eax = Caml_state->young_ptr - size */
@@ -209,7 +237,7 @@ FUNCTION(caml_c_call)
         CFI_STARTPROC
     /* Record lowest stack address and return address */
     /* ecx and edx are destroyed at C call. Use them as temp. */
-        movl    G(Caml_state), %ecx
+        MOV_CAML_STATE_PTR(l_caml_c_call, %ecx)
         movl    (%esp), %edx
         movl    %edx, CAML_STATE(last_return_address, %ecx)
         leal    4(%esp), %edx
@@ -228,37 +256,76 @@ FUNCTION(caml_c_call)
 
 /* Start the OCaml program */
 
-FUNCTION(caml_start_program)
-        CFI_STARTPROC
-    /* Save callee-save registers */
-        pushl   %ebx; CFI_ADJUST(4)
-        pushl   %esi; CFI_ADJUST(4)
-        pushl   %edi; CFI_ADJUST(4)
-        pushl   %ebp; CFI_ADJUST(4)
-    /* Initial entry point is caml_program */
-        movl    $ G(caml_program), %esi
-    /* Common code for caml_start_program and caml_callback* */
-LBL(106):
-        movl    G(Caml_state), %edi
+     /* Common code for caml_start_program and caml_callback* */
+        .macro inline_jump_to_caml_header label
+        MOV_CAML_STATE_PTR(\label, %edi)
     /* Build a callback link */
         pushl   CAML_STATE(gc_regs, %edi); CFI_ADJUST(4)
         pushl   CAML_STATE(last_return_address, %edi); CFI_ADJUST(4)
         pushl   CAML_STATE(bottom_of_stack, %edi); CFI_ADJUST(4)
         /* Note: 16-alignment preserved on MacOSX at this point */
     /* Build an exception handler */
+#ifdef __PIC__
+        pushl   %ebx                                 /* Push C = orig(ebx) */
+        sub     $ 4, %esp                            /* Push B = <tmp> */
+        call    inline_jump_to_caml_exception_\label /* Push IP register */
+inline_jump_to_caml_exception_\label:
+        popl    %ebx                                 /* Pop IP register */
+        addl    $_GLOBAL_OFFSET_TABLE_, %ebx
+        movl    LBL(108)@GOT(%ebx), %ebx             /* ebx = $ LBL(108) */
+        pushl   %ebx                                 /* Push A = $ LBL(108) */
+                                                     /* Stack = A, B, C */
+        movl    8(%esp), %ebx
+        movl    %ebx,    4(%esp)                     /* Stack = A, C, C */
+        movl    0(%esp), %ebx
+        movl    %ebx,    8(%esp)                     /* Stack = A, C, A */
+        movl    4(%esp), %ebx                        /* ebx = C = orig(ebx) */
+        add     $ 8, %esp                            /* Stack = A = $ LBL(108) */
+#else
         pushl   $ LBL(108); CFI_ADJUST(4)
+#endif
         ALIGN_STACK(8)
         pushl   CAML_STATE(exception_pointer, %edi); CFI_ADJUST(4)
         movl    %esp, CAML_STATE(exception_pointer, %edi)
+        .endm
+
+        .macro inline_jump_to_caml_plt label caml_code_funcptr
+    /* Call the OCaml code */
+        pushl   %ebx                           /* Protect ebx */
+        call    inline_jump_to_caml_plt_\label /* Push IP register */
+inline_jump_to_caml_plt_\label:
+        popl    %ebx                           /* Pop IP register */
+        addl    $_GLOBAL_OFFSET_TABLE_, %ebx   /* ebx=GOT on PLT entry */
+        call    \caml_code_funcptr@PLT
+        popl    %ebx
+        .endm
+
+FUNCTION(caml_start_program)
+        CFI_STARTPROC
+    /* Save callee-save registers */
+        pushl   %ebx; CFI_ADJUST(4)
+        pushl   %esi; CFI_ADJUST(4)
+        pushl   %edi; CFI_ADJUST(4)
+        pushl   %ebp; CFI_ADJUST(4)
+    /* Initial entry point is caml_program */
+#ifdef __PIC__
+        inline_jump_to_caml_header caml_start_program_initial
+        inline_jump_to_caml_plt    caml_start_program_initial caml_program
+#else
+        movl    $ G(caml_program), %esi
+#endif
+    /* Regardless of PIC status, this local label will be used by caml_callback_asm() */
+LBL(106):
+        inline_jump_to_caml_header caml_start_program_106
     /* Call the OCaml code */
         call    *%esi
 LBL(107):
-        movl    G(Caml_state), %edi
+        MOV_CAML_STATE_PTR(l_caml_start_program_107, %edi)
     /* Pop the exception handler */
         popl    CAML_STATE(exception_pointer, %edi); CFI_ADJUST(-4)
         addl    $12, %esp       ; CFI_ADJUST(-12)
 LBL(109):
-        movl    G(Caml_state), %edi /* Reload for LBL(109) entry */
+        MOV_CAML_STATE_PTR(l_caml_start_program_109, %edi) /* Reload for LBL(109) entry */
     /* Pop the callback link, restoring the global variables */
         popl    CAML_STATE(bottom_of_stack, %edi); CFI_ADJUST(-4)
         popl    CAML_STATE(last_return_address, %edi); CFI_ADJUST(-4)
@@ -282,7 +349,7 @@ LBL(108):
 
 FUNCTION(caml_raise_exn)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
+        MOV_CAML_STATE_PTR(l_caml_raise_exn, %ebx)
         testl   $1, CAML_STATE(backtrace_active, %ebx)
         jne     LBL(110)
         movl    CAML_STATE(exception_pointer, %ebx), %esp
@@ -299,7 +366,7 @@ LBL(110):
         pushl   %edx; CFI_ADJUST(4)         /* arg 3: sp of raise */
         pushl   %eax; CFI_ADJUST(4)         /* arg 2: pc of raise */
         pushl   %esi; CFI_ADJUST(4)         /* arg 1: exception bucket */
-        call    G(caml_stash_backtrace)
+        call_global_func caml_stash_backtrace, l_caml_raise_exn
         movl    %esi, %eax              /* Recover exception bucket */
         movl    %edi, %esp
         popl    CAML_STATE(exception_pointer, %ebx); CFI_ADJUST(-4)
@@ -312,7 +379,7 @@ LBL(110):
 
 FUNCTION(caml_raise_exception)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
+        MOV_CAML_STATE_PTR(l_caml_raise_exception, %ebx)
         testl   $1, CAML_STATE(backtrace_active, %ebx)
         jne     LBL(112)
         movl    8(%esp), %eax
@@ -331,7 +398,7 @@ LBL(112):
         pushl   CAML_STATE(last_return_address, %ebx); CFI_ADJUST(4)
         /* 1: exception bucket */
         pushl   %esi; CFI_ADJUST(4)
-        call    G(caml_stash_backtrace)
+        call_global_func caml_stash_backtrace, l_caml_raise_exception
         movl    %esi, %eax              /* Recover exception bucket */
         movl    CAML_STATE(exception_pointer, %ebx), %esp
         popl    CAML_STATE(exception_pointer, %ebx); CFI_ADJUST(-4)
@@ -370,8 +437,13 @@ FUNCTION(caml_callback2_asm)
         movl    28(%esp), %edi   /* arguments array */
         movl    0(%edi), %eax    /* arg1: first argument */
         movl    4(%edi), %ebx    /* arg2: second argument */
+#ifdef __PIC__
+        inline_jump_to_caml_header caml_callback2_asm
+        inline_jump_to_caml_plt    caml_callback2_asm caml_apply2
+#else
         movl    $ G(caml_apply2), %esi   /* code pointer */
         jmp     LBL(106)
+#endif
         CFI_ENDPROC
 ENDFUNCTION(caml_callback2_asm)
 
@@ -388,8 +460,13 @@ FUNCTION(caml_callback3_asm)
         movl    0(%edi), %eax    /* arg1: first argument */
         movl    4(%edi), %ebx    /* arg2: second argument */
         movl    8(%edi), %ecx    /* arg3: third argument */
+#ifdef __PIC__
+        inline_jump_to_caml_header caml_callback3_asm
+        inline_jump_to_caml_plt    caml_callback3_asm caml_apply3
+#else
         movl    $ G(caml_apply3), %esi   /* code pointer */
         jmp     LBL(106)
+#endif
         CFI_ENDPROC
 ENDFUNCTION(caml_callback3_asm)
 
@@ -405,7 +482,7 @@ FUNCTION(caml_ml_array_bound_error)
         ffree   %st(6)
         ffree   %st(7)
     /* Record lowest stack address and return address */
-        movl    G(Caml_state), %ebx
+        MOV_CAML_STATE_PTR(l_caml_ml_array_bound_error, %ebx)
         movl    (%esp), %edx
         movl    %edx, CAML_STATE(last_return_address, %ebx)
         leal    4(%esp), %edx
@@ -413,7 +490,7 @@ FUNCTION(caml_ml_array_bound_error)
     /* Re-align the stack */
         andl    $-16, %esp
     /* Branch to [caml_array_bound_error] (never returns) */
-        call    G(caml_array_bound_error)
+        call_global_func caml_array_bound_error, l_caml_ml_array_bound_error
         CFI_ENDPROC
         ENDFUNCTION(caml_ml_array_bound_error)
 
diff --git a/utils/Makefile b/utils/Makefile
index 11e2cebe2..286538fdd 100644
--- a/utils/Makefile
+++ b/utils/Makefile
@@ -83,6 +83,7 @@ config.ml: config.mlp $(ROOTDIR)/Makefile.config Makefile
 	    $(call SUBST,SYSTEM) \
 	    $(call SUBST,SYSTHREAD_SUPPORT) \
 	    $(call SUBST,TARGET) \
+	    $(call SUBST,TARGET_OS) \
 	    $(call SUBST,WITH_FRAME_POINTERS) \
 	    $(call SUBST,WITH_PROFINFO) \
 	    $(call SUBST,FLAT_FLOAT_ARRAY) \
diff --git a/utils/clflags.ml b/utils/clflags.ml
index a193d53d2..0dc2b90f0 100644
--- a/utils/clflags.ml
+++ b/utils/clflags.ml
@@ -160,9 +160,15 @@ let std_include_dir () =
 let shared = ref false (* -shared *)
 let dlcode = ref true (* not -nodynlink *)
 
-let pic_code = ref (match Config.architecture with (* -fPIC *)
-                     | "amd64" -> true
-                     | _       -> false)
+let pic_code = ref (
+  let android =
+    let l = String.length "linux-android" in
+    String.length Config.target_os >= l && String.equal (String.sub Config.target_os 0 l) "linux-android"
+  in
+  match Config.architecture, android with (* -fPIC *)
+    | "amd64", _ -> true
+    | _, true    -> true
+    | _          -> false)
 
 let runtime_variant = ref "";;      (* -runtime-variant *)
 let with_runtime = ref true;;         (* -with-runtime *)
diff --git a/utils/config.mli b/utils/config.mli
index 1b73eed02..6d5eade22 100644
--- a/utils/config.mli
+++ b/utils/config.mli
@@ -194,6 +194,9 @@ val host : string
 val target : string
 (** Whether the compiler is a cross-compiler *)
 
+val target_os : string
+(** The OS part of the target ABI triplet *)
+
 val flambda : bool
 (** Whether the compiler was configured for flambda *)
 
diff --git a/utils/config.mlp b/utils/config.mlp
index 5bfa30d69..259f6b59e 100644
--- a/utils/config.mlp
+++ b/utils/config.mlp
@@ -136,6 +136,7 @@ let ext_dll = "%%EXT_DLL%%"
 
 let host = "%%HOST%%"
 let target = "%%TARGET%%"
+let target_os = "%%TARGET_OS%%"
 
 let default_executable_name =
   match Sys.os_type with
