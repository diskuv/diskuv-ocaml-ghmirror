Compiling OCaml in Depth
========================

We will begin the discussion with an overview of how OCaml is compiled. We will see that one OCaml system
is used to compile another OCaml system ... the OCaml system you have on your machine. That understanding
of one system compiling another will be essential to understanding how the cross-compilation works.

We will come back to cross-compilation at the end. The second part of the discussion is how C is compiled
and assembly language are compiled, and where the C and assembly language compilers get invoked.

Then we will discuss how cross-compilation typically works in the C language.

Finally we will conclude with how cross-compilation works in OCaml.

How OCaml is compiled
---------------------

In this section we will walk through the source code for OCaml at https://github.com/ocaml/ocaml/tree/4.13.

.. note::
    Parts of the explanation below comes from https://github.com/ocaml/ocaml/blob/4.13/BOOTSTRAP.adoc

Let's start with the ``boot/`` directory:

.. code:: text

    boot
    ├── menhir
    │   ├── menhirLib.ml
    │   ├── menhirLib.mli
    │   ├── parser.ml
    │   └── parser.mli
    ├── ocamlc
    └── ocamllex

Both ``boot/ocamlc`` and ``boot/ocamllex`` are OCaml bytecode files. OCaml bytecode is a machine language code
for a very simple virtual machine called the
`Caml Virtual Machine (or Zinc Machine) <http://cadmium.x9c.fr/distrib/caml-instructions.pdf>`_.

``ocamllex`` is the token lexer. If we could run ``ocamllex`` then we could take a ``.ml`` OCaml source file and emit OCaml tokens
(ex. ``=``) and keywords (ex. ``module``) that could be consumed by the OCaml parser ``parser.ml`` and its runtime library
``menhirLib.ml``. The end result would be an `abstract syntax tree called a Parsetree <https://ocaml.org/api/compilerlibref/Parsetree.html>`_
from a single ``.ml`` source file.

``ocamlc`` is the bytecode compiler. If we could run ``ocamlc`` then we could take any ``.ml`` source code
and generate more bytecode.

All we are missing so far is a way to run arbitrary bytecode files like ``ocamlc`` and ``ocamllex``. That missing
program is ``ocamlrun``: ``ocamlrun`` is the bytecode interpreter for the Caml Virtual Machine. 

To build executables like the ``ocamlrun`` bytecode interpreter, OCaml uses an "autoconf" build system where:

- ``./configure`` inspects your system to find C compilers (that is how we know which C compiler to
  use to generate the ``ocamlrun`` program) and assembly language compilers. It captures the C and assembly
  compilers and their flags into ``./Makefile.config`` using a template file ``Makefile.config.in``. There
  are also other files created from ``*.in`` templates
- ``make`` uses the configuration captured in ``./Makefile.config`` to generate the ``utils/config.ml`` module
  from the ``utils/config.mlp`` template. There are also other modules created from ``*.mlp``
  templates. After ``make`` has generated all the source files, it can build C programs like ``ocamlrun``
  using the C compiler and OCaml programs like ``ocaml`` and ``ocamlc`` using ``ocamlrun boot/ocamlc``.

``ocamlrun`` is compiled using a mix of C code (``.c``) and assembly code (``.asm`` and ``.S``).
Here is an abbreviated listing of ocamlrun source code:

.. code:: text

    runtime
    ├── alloc.c
    ├── amd64.S
    ├── amd64nt.asm
    ├── arm.S
    ├── arm64.S
    ├── array.c
    ├── backtrace.c
    ├── callback.c
    ├── caml
    │   ├── alloc.h
    │   ├── backtrace.h
    │   ├── callback.h
    │   ├── config.h
    │   ├── domain.h
    │   ├── domain_state.h
    │   ├── domain_state.tbl
    │   ├── gc.h
    │   ├── gc_ctrl.h
    │   ├── io.h
    │   ├── m.h
    │   ├── m.h.in
    │   ├── major_gc.h
    │   ├── minor_gc.h
    │   ├── prims.h
    │   ├── s.h
    │   ├── s.h.in
    │   ├── signals.h
    │   ├── startup.h
    │   ├── startup_aux.h
    │   └── sys.h
    ├── domain.c
    ├── hash.c
    ├── i386.S
    ├── i386nt.asm
    ├── io.c
    ├── lexing.c
    ├── main.c
    ├── major_gc.c
    ├── minor_gc.c
    ├── parsing.c
    ├── power.S
    ├── prims.c
    ├── riscv.S
    ├── s390x.S
    ├── signals.c
    ├── startup_aux.c
    ├── startup_nat.c
    ├── str.c
    ├── sys.c
    ├── unix.c
    └── win32.c

After ``make`` compiles the ``runtime/`` directory with the C compiler and assembly language compiler we will have the
``runtime/ocamlrun`` executable that can run any bytecode file. We can now:

- compile OCaml files with ``runtime/ocamlrun boot/ocamlc`` and run the generated bytecode with ``runtime/ocamlrun``
- interact with Unix/Windows system library C functions from within bytecode since the compiled assembly language (ex. ``amd64.S``)
  contains low-level logic for OCaml to call C functions and C functions to callback into OCaml

That sounds like we are finished, but we now have three problems.

Problem 1: Creating a modern OCaml compiler
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The first problem is that we have been using the ``boot/ocamlc`` OCaml compiler. That boot OCaml compiler may be an old OCaml compiler
that can't compile the latest OCaml source code. So we compile a new OCaml compiler ``./ocamlc`` bytecode file from the following
abbreviated OCaml compiler source code:

.. code:: text

    .
    ├── bytecomp
    │   ├── bytegen.ml
    │   ├── bytelibrarian.ml
    │   ├── bytelink.ml
    │   ├── bytepackager.ml
    │   ├── bytesections.ml
    │   ├── dll.ml
    │   ├── emitcode.ml
    │   ├── instruct.ml
    │   ├── meta.ml
    │   ├── opcodes.ml
    │   ├── printinstr.ml
    │   └── symtable.ml
    ├── driver
    │   ├── compenv.ml
    │   ├── compile.ml
    │   ├── compile_common.ml
    │   ├── compmisc.ml
    │   ├── errors.ml
    │   ├── main.ml
    │   ├── main_args.ml
    │   ├── maindriver.ml
    │   ├── makedepend.ml
    │   ├── optcompile.ml
    │   ├── opterrors.ml
    │   ├── optmain.ml
    │   ├── optmaindriver.ml
    │   └── pparse.ml
    ├── lambda
    │   ├── debuginfo.ml
    │   ├── lambda.ml
    │   ├── matching.ml
    │   ├── printlambda.ml
    │   ├── runtimedef.ml
    │   ├── simplif.ml
    │   ├── switch.ml
    │   ├── translattribute.ml
    │   ├── translclass.ml
    │   ├── translcore.ml
    │   ├── translmod.ml
    │   ├── translobj.ml
    |   └── translprim.ml
    └── typing
    |   ├── btype.ml
    |   ├── ...
    |   ├── ctype.ml
    |   ├── ...
    |   ├── primitive.ml
    |   ├── ...
    |   ├── type_immediacy.ml
    |   ├── typeclass.ml
    |   ├── typecore.ml
    |   ├── typedecl.ml
    |   ├── typedecl_immediacy.ml
    |   ├── typedecl_properties.ml
    |   ├── typedecl_separability.ml
    |   ├── typedecl_unboxed.ml
    |   ├── typedecl_variance.ml
    |   ├── typedtree.ml
    |   ├── typemod.ml
    |   ├── typeopt.ml
    |   ├── types.ml
    |   ├── typetexp.ml
    |   └── untypeast.ml
    └── utils/
        ├── ...
        ├── clflags.ml
        ├── config.ml
        ├── config.mlp
        ├── ...

Once we have a modern ``./ocamlc`` we can see the configuration constants embedded in ``utils/config.ml`` if you run ``runtime/ocamlrun ./ocamlc -config``:

.. code:: text

    version: 4.12.1
    ...
    ccomp_type: cc
    c_compiler: gcc
    ocamlc_cflags: -O2 -fno-strict-aliasing -fwrapv -fPIC
    ocamlc_cppflags: -D_FILE_OFFSET_BITS=64 -D_REENTRANT
    ocamlopt_cflags: -O2 -fno-strict-aliasing -fwrapv -fPIC
    ocamlopt_cppflags: -D_FILE_OFFSET_BITS=64 -D_REENTRANT
    bytecomp_c_compiler: gcc -O2 -fno-strict-aliasing -fwrapv -fPIC  -D_FILE_OFFSET_BITS=64 -D_REENTRANT
    native_c_compiler: gcc -O2 -fno-strict-aliasing -fwrapv -fPIC  -D_FILE_OFFSET_BITS=64 -D_REENTRANT
    bytecomp_c_libraries: -lm -ldl  -lpthread
    native_c_libraries: -lm -ldl
    native_pack_linker: ld -r -o
    ranlib: ranlib
    ...
    asm: gcc -c
    ...

The net effect is that the C and assembly compilers are hardcoded _inside_ the ``ocamlc`` executable.

Problem 2: Creating the standard library
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The second problem is that we don't have the OCaml standard library. We can compile the standard library
bytecode (``.cmo`` object files and ``.cma`` object libraries) from:

.. code:: text

    stdlib
    ├── arg.ml
    ├── array.ml
    ├── arrayLabels.ml
    ├── atomic.ml
    ├── bigarray.ml
    ├── bool.ml
    ├── buffer.ml
    ├── bytes.ml
    ├── bytesLabels.ml
    ├── callback.ml
    ├── char.ml
    ├── complex.ml
    ├── digest.ml
    ├── either.ml
    ├── ephemeron.ml
    ├── filename.ml
    ├── float.ml
    ├── format.ml
    ├── fun.ml
    ├── gc.ml
    ├── genlex.ml
    ├── hashbang
    ├── hashtbl.ml
    ├── header.c
    ├── headernt.c
    ├── int.ml
    ├── int32.ml
    ├── int64.ml
    ├── lazy.ml
    ├── lexing.ml
    ├── list.ml
    ├── listLabels.ml
    ├── map.ml
    ├── marshal.ml
    ├── moreLabels.ml
    ├── nativeint.ml
    ├── obj.ml
    ├── oo.ml
    ├── option.ml
    ├── parsing.ml
    ├── pervasives.ml
    ├── printexc.ml
    ├── printf.ml
    ├── queue.ml
    ├── random.ml
    ├── result.ml
    ├── scanf.ml
    ├── seq.ml
    ├── set.ml
    ├── stack.ml
    ├── stdLabels.ml
    ├── std_exit.ml
    ├── stdlib.a
    ├── stdlib.ml
    ├── stream.ml
    ├── string.ml
    ├── stringLabels.ml
    ├── sys.ml
    ├── sys.mlp
    ├── uchar.ml
    ├── unit.ml
    └── weak.ml

Problem 3: Generating native code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The third problem is that we completely ignored how we will generate native code. That is the subject of discussion for the
next section.

Where C and assembly compilers are used
---------------------------------------

We've already discussed how the OCaml compiler itself uses a C compiler to compile the runtime/ directory into the ``ocamlrun`` program. And
how ``ocamlrun`` can run other bytecode files and generate (with ``ocamlc``) more bytecode files.

OCaml's native code compiler program ``./ocamlopt`` is build the same way we built ``./ocamlc``, except ``bytecomp/`` has been replaced by ``asmcomp/``
and ``middle_end/``:

.. code:: text

    .
    ├── asmcomp
    │   ├── CSE.ml -> arm/CSE.ml
    │   ├── CSEgen.ml
    │   ├── amd64
    │   │   ├── CSE.ml
    │   │   ├── arch.ml
    │   │   ├── emit.mlp
    │   │   ├── proc.ml
    │   │   ├── reload.ml
    │   │   ├── scheduling.ml
    │   │   └── selection.ml
    │   ├── arch.ml -> arm/arch.ml
    │   ├── arm
    │   │   ├── CSE.ml
    │   │   ├── arch.ml
    │   │   ├── emit.mlp
    │   │   ├── proc.ml
    │   │   ├── reload.ml
    │   │   ├── scheduling.ml
    │   │   └── selection.ml
    │   ├── arm64
    │   │   └── \*.ml
    │   ├── asmgen.ml
    │   ├── asmlibrarian.ml
    │   ├── asmlink.ml
    │   ├── asmpackager.ml
    │   ├── branch_relaxation.ml
    │   ├── branch_relaxation_intf.ml
    │   ├── cmm.ml
    │   ├── cmm_helpers.ml
    │   ├── cmmgen.ml
    │   ├── cmmgen_state.ml
    │   ├── coloring.ml
    │   ├── comballoc.ml
    │   ├── deadcode.ml
    │   ├── emit.ml
    │   ├── emitaux.ml
    │   ├── i386
    │   │   └── \*.ml
    │   ├── interf.ml
    │   ├── interval.ml
    │   ├── linear.ml
    │   ├── linearize.ml
    │   ├── linscan.ml
    │   ├── liveness.ml
    │   ├── mach.ml
    │   ├── power
    │   │   └── \*.ml
    │   ├── printcmm.ml
    │   ├── printlinear.ml
    │   ├── printmach.ml
    │   ├── proc.ml -> arm/proc.ml
    │   ├── reg.ml
    │   ├── reload.ml -> arm/reload.ml
    │   ├── reloadgen.ml
    │   ├── riscv
    │   │   └── \*.ml
    │   ├── s390x
    │   │   └── \*.ml
    │   ├── schedgen.ml
    │   ├── scheduling.ml -> arm/scheduling.ml
    │   ├── selectgen.ml
    │   ├── selection.ml -> arm/selection.ml
    │   ├── spill.ml
    │   ├── split.ml
    │   ├── strmatch.ml
    │   ├── x86_dsl.ml
    │   ├── x86_gas.ml
    │   ├── x86_masm.ml
    │   └── x86_proc.ml
    ├── driver
    │   └── \*.ml
    ├── lambda
    │   └── \*.ml
    ├── middle_end
    │   ├── backend_var.ml
    │   ├── clambda.ml
    │   ├── clambda_primitives.ml
    │   ├── closure
    │   │   ├── closure.ml
    │   │   └── closure_middle_end.ml
    │   ├── compilation_unit.ml
    │   ├── compilenv.ml
    │   ├── convert_primitives.ml
    │   ├── flambda
    │   │   ├── alias_analysis.ml
    │   │   ├── allocated_const.ml
    │   │   ├── augment_specialised_args.ml
    │   │   ├── base_types
    │   │   ├── build_export_info.ml
    │   │   ├── closure_conversion.ml
    │   │   ├── closure_conversion_aux.ml
    │   │   ├── closure_offsets.ml
    │   │   ├── effect_analysis.ml
    │   │   ├── export_info.ml
    │   │   ├── export_info_for_pack.ml
    │   │   ├── extract_projections.ml
    │   │   ├── find_recursive_functions.ml
    │   │   ├── flambda.ml
    │   │   ├── flambda_invariants.ml
    │   │   ├── flambda_iterators.ml
    │   │   ├── flambda_middle_end.ml
    │   │   ├── flambda_to_clambda.ml
    │   │   ├── flambda_utils.ml
    │   │   ├── freshening.ml
    │   │   ├── import_approx.ml
    │   │   ├── inconstant_idents.ml
    │   │   ├── initialize_symbol_to_let_symbol.ml
    │   │   ├── inline_and_simplify.ml
    │   │   ├── inline_and_simplify_aux.ml
    │   │   ├── inlining_cost.ml
    │   │   ├── inlining_decision.ml
    │   │   ├── inlining_stats.ml
    │   │   ├── inlining_stats_types.ml
    │   │   ├── inlining_transforms.ml
    │   │   ├── invariant_params.ml
    │   │   ├── lift_code.ml
    │   │   ├── lift_constants.ml
    │   │   ├── lift_let_to_initialize_symbol.ml
    │   │   ├── parameter.ml
    │   │   ├── pass_wrapper.ml
    │   │   ├── projection.ml
    │   │   ├── ref_to_variables.ml
    │   │   ├── remove_free_vars_equal_to_args.ml
    │   │   ├── remove_unused_arguments.ml
    │   │   ├── remove_unused_closure_vars.ml
    │   │   ├── remove_unused_program_constructs.ml
    │   │   ├── share_constants.ml
    │   │   ├── simple_value_approx.ml
    │   │   ├── simplify_boxed_integer_ops.ml
    │   │   ├── simplify_common.ml
    │   │   ├── simplify_primitives.ml
    │   │   ├── traverse_for_exported_symbols.ml
    │   │   ├── un_anf.ml
    │   │   ├── unbox_closures.ml
    │   │   ├── unbox_free_vars_of_closures.ml
    │   │   └── unbox_specialised_args.ml
    │   ├── internal_variable_names.ml
    │   ├── linkage_name.ml
    │   ├── printclambda.ml
    │   ├── printclambda_primitives.ml
    │   ├── semantics_of_primitives.ml
    │   ├── symbol.ml
    │   └── variable.ml
    └── typing
        └── \*.ml

``ocamlopt`` performs a variety of activities including:

- it translates ``.ml`` files into architecture-specific assembly language source code (``.s`` files) using the code in
  ``asmcomp/``. ``ocamlopt`` then compiles the assembly language into native object files (Unix ``.o`` or Windows ``.obj`` files)
  using the assembly compiler named in the ``utils/config.ml`` module (the same module you saw with ``ocamlc -config``)
- it compiles ``.C`` files into native object files using the C compiler named in ``utils/config.ml``
- it links the native object files into a native executable using the native linker named in ``utils/config.ml``

Now we are basically done. With ``ocamlopt`` we can recompile everything into native code, including the compilers.
For example ``./ocamlc.opt`` and ``./ocamlopt.opt`` are created using the same procedure as ``./ocamlc`` and ``./ocamlopt``, except instead
of using ``./ocamlc`` to compile them into bytecode executable, ``./ocamlopt`` is used to compile them into native code executables.

How C is cross-compiled
-----------------------

Changing OCaml to do cross-compilation
--------------------------------------

.. note::
    The technique presented here was first described by EduardoRFS,
    Antonio Nuno Monteiro and Romain Beauxis in
    `discuss.ocaml.org: Cross-compiling implementations / how they work <https://discuss.ocaml.org/t/cross-compiling-implementations-how-they-work/8686>`_

